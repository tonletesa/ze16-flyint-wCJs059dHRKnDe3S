[合集 - 技术札纪——有限硬件与无限计算的权衡艺术(50)](https://github.com)

[1.书本介绍：技术札纪——有限硬件与无限计算的权衡艺术07-24](https://github.com/poemyang/p/19002322)[2.书本大纲：从芯片、分布式到云计算AI时代07-25](https://github.com/poemyang/p/19004265)[3.我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？07-25](https://github.com/poemyang/p/19004704)[4.我的代码出现幻觉？说好的a = 1； x = b，怎么成了x = b； a = 1？07-28](https://github.com/poemyang/p/19008983)[5.为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”07-29](https://github.com/poemyang/p/19010948)[6.没有Happens-Before？你的多线程代码就是‘一锅粥’！07-30](https://github.com/poemyang/p/19012883)[7.Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法07-31](https://github.com/poemyang/p/19014740)[8.a+b=c，处理器一步搞定，Java虚拟机为啥要四步？08-01](https://github.com/poemyang/p/19016482)[9.“同声传译”还是“全文翻译”？为何HotSpot虚拟机仍要保留解释器？08-04](https://github.com/poemyang/p/19020937)[10.“代码跑着跑着，就变快了？”——揭秘Java性能幕后引擎：即时编译器08-05](https://github.com/poemyang/p/19022518)[11.Java编译器优化秘籍：字节码背后的IR魔法与常见技巧08-06](https://github.com/poemyang/p/19024509)[12.解锁硬件潜能：Java向量化计算，性能飙升W倍！08-07](https://github.com/poemyang/p/19026352)[13.new出来的对象，不一定在堆上？聊聊Java虚拟机的优化技术：逃逸分析08-08](https://github.com/poemyang/p/19027777)[14.性能优化之母：为什么说“方法内联”是编译器优化中最关键的一步棋？08-11](https://github.com/poemyang/p/19031406)[15.从纳秒到毫秒的“时空之旅”：CPU是如何看待内存与硬盘的？08-12](https://github.com/poemyang/p/19033086)[16.硬盘性能提升100倍的秘密：看懂顺序I/O的魔力08-14](https://github.com/poemyang/p/19038725)[17.十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解08-18](https://github.com/poemyang/p/19043960)[18.Facebook内部都在用的存储引擎，LSM凭什么能硬扛亿级写入流量？08-21](https://github.com/poemyang/p/19050442)[19.千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！08-22](https://github.com/poemyang/p/19052513)[20.RPC的三大问题：跨语言、跨平台通信的终极解决方案是如何炼成的？08-27](https://github.com/poemyang/p/19060527)[21.从文本到二进制：HTTP/2不止于性能，更是对HTTP/1核心语义的传承与革新08-28](https://github.com/poemyang/p/19061836)[22.从HPACK到多路复用，揭秘HTTP/2如何终结网络拥堵08-29](https://github.com/poemyang/p/19063734)[23.站在巨人的肩膀上：gRPC通过HTTP/2构建云原生时代的通信标准09-01](https://github.com/poemyang/p/19068100)[24.gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？09-03](https://github.com/poemyang/p/19071487)[25.从JSON到Protobuf，深入序列化方案的选型与原理09-04](https://github.com/poemyang/p/19073206):[蓝猫加速器配置下载](https://yunbeijia.com)[26.“卧槽，系统又崩了！”——别慌，这也许是你看过最通俗易懂的分布式入门09-05](https://github.com/poemyang/p/19074847)[27.海量数据如何“安家”？一文读懂哈希、范围和一致性哈希三大分片策略09-08](https://github.com/poemyang/p/19079520)[28.“你还活着吗？” “我没死，只是网卡了！”——来自分布式世界的“生死契约”09-09](https://github.com/poemyang/p/19082361)[29.“凭什么说你比我先？”——没有上帝时钟，如何判断“谁先谁后”？09-12](https://github.com/poemyang/p/19087563)[30.“鸡蛋不能放一个篮子里”，如何确保千亿数据万无一失？09-15](https://github.com/poemyang/p/19092154)[31.系统里数据又“打架”了？让“少数服从多数”来终结这场混乱！09-18](https://github.com/poemyang/p/19097975)[32.技术圈的“绯闻女孩”：Gossip是如何把八卦秘密传遍全网的？09-19](https://github.com/poemyang/p/19100196)[33.绯闻女孩不只会八卦：从“验明正身”到“抓内鬼”，Gossip的进阶玩法09-20](https://github.com/poemyang/p/19101931)[34.从混沌到秩序：Java共享内存模型如何通过显式约束驯服并发？09-23](https://github.com/poemyang/p/19106679)[35.一把锁的两种承诺：synchronized如何同时保证互斥与内存可见性？09-24](https://github.com/poemyang/p/19108676)[36.从MESA模型到锁升级：synchronized性能逆袭的底层逻辑09-25](https://github.com/poemyang/p/19110705)[37.揭秘JUC：volatile与CAS，并发编程的两大基石09-27](https://github.com/poemyang/p/19114881)[38.“不要通过共享内存来通信”——深入理解Golang并发模型与CSP理论10-13](https://github.com/poemyang/p/19139419)[39.Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？10-14](https://github.com/poemyang/p/19142146)[40.“一切皆文件”：揭秘LINUX I/O与虚拟内存的底层设计哲学10-15](https://github.com/poemyang/p/19143895)[41.你的程序为何卡顿？从LINUX I/O三大模式寻找答案10-16](https://github.com/poemyang/p/19146666)[42.单线程如何撑起百万连接？I/O多路复用：现代网络架构的基石10-17](https://github.com/poemyang/p/19148798)[43.从C10K到Reactor：事件驱动，如何重塑高并发服务器的网络架构10-20](https://github.com/poemyang/p/19153675)[44.职责分离的艺术：剖析主从Reactor模型如何实现极致的并发性能10-21](https://github.com/poemyang/p/19156356)[45.“化零为整”的智慧：内存池如何绕过系统调用和GC，构建性能的护城河10-22](https://github.com/poemyang/p/19159101)[46.jemalloc思想的极致演绎：深度解构Netty内存池的精妙设计与实现10-23](https://github.com/poemyang/p/19160579)[47.为什么Java/Python程序无需关心内存释放？揭秘垃圾回收（GC）的核心概念10-25](https://github.com/poemyang/p/19166120)[48.压缩指针：64位系统下，Java虚拟机是如何“偷”回4字节内存的？10-27](https://github.com/poemyang/p/19170159)[49.谁生？谁死？从引用计数到可达性分析，洞悉GC的决策逻辑10-29](https://github.com/poemyang/p/19172986)

50.为什么我的应用会卡顿？垃圾回收中的STW难题与破解之道10-30

收起

**垃圾回收算法：清除、压缩、复制**
可达性分析提供了一种有效的方式，来标记哪些对象死亡，哪些对象还存活。然而，确定哪些对象死亡可以被回收，只是垃圾回收的第一步， 这个过程通常被称为标记（Mark）。接下来，需要一种方法来回收这些死亡对象占用的内存，以便这些内存可以被重新使用。这就是垃圾回收算法的任务。
垃圾回收算法描述了如何有效地回收垃圾对象的内存，同时尽量减少对程序执行的影响。

**清除**
清除（Sweep）算法的主要操作是将不再活跃的对象的内存标记为可用，并将这些内存信息记录在一个叫做空闲列表（Free List）的数据结构中。当程序需要实例化新的对象时，内存管理模块会从空闲列表中找到可用的内存空间，分配给新对象。
清除算法的主要缺点是可能导致内存碎片化。因为在堆内存中，对象的存储必须是连续的，可能会出现总的空闲内存充足，但无法找到足够大的连续内存空间来存储新的对象的情况。
另一个缺点是清除策略的内存分配效率较低。如果内存是连续的空间，可以通过简单的指针运算，比如指针加法（Pointer Bumping），快速分配内存。但对于清除算法中的空闲列表，需要逐一检查列表中的每一项，找到足够大的空闲内存来存储新的对象，这个过程相对耗时
![image](https://img2024.cnblogs.com/blog/757914/202510/757914-20251030121534452-1468999076.png)

**压缩**
压缩（Compact）算法的主要操作是将所有存活的对象移动至内存的一端，使这些对象在内存中连续排列，并更新所有指向这些对象的引用。这样，所有未被标记的对象都被挤压到内存的另一端，可以一次性回收。
压缩算法的优点是可以避免内存碎片，因为所有活动对象在压缩时都被紧凑排列。此外，这种算法不需要额外的内存空间，因为所有操作都在原地完成。
然而，压缩算法也有缺点。首先，压缩可能改变对象在内存中的位置，可能影响程序性能。其次，如果活动对象占据了大部分内存，压缩过程可能会非常耗时。
![image](https://img2024.cnblogs.com/blog/757914/202510/757914-20251030121550406-1745853713.png)

**复制**
复制（Copy）算法的主要操作是将所有活动的对象复制到内存的另一部分（通常称为to-space），并更新所有指向这些对象的引用。复制后，原来的内存区域（即from-space）中的所有对象都被视为垃圾，可以一次性回收。
复制算法的优势在于避免内存碎片，因为所有活动对象在复制时都被紧凑排列。此外，由于只处理活动对象，所以当大部分内存被垃圾对象占据时，此算法效率高。
然而，复制算法也有缺点。首先，它需要额外内存空间存放复制的对象。其次，复制过程可能改变对象在内存中的位置，可能影响程序性能。
![image]()

**并发标记：与时间赛跑的追踪游戏**
标记阶段是所有追踪式垃圾回收算法的共同特征，这个阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾回收过程，同理可知，如果能够削减这部分停顿时间的话，那收益也将会是系统性的。
为了解决原始标记阶段带来的长时间停顿，多数现代的追踪式垃圾回收算法都会实现三色标记（Tri-color Marking）算法的变种以缩短停顿的时间。三色标记算法将程序中的对象分成白色、黑色和灰色三类。
1）白色对象：不活动对象，没有被其他对象引用，或者从根节点开始无法到达的对象；
2）灰色对象：活动对象，被其他对象引用，或者从根节点开始可以到达的对象。但是，这些对象引用的对象还没有被检查；
3）黑色对象：活动对象，从根节点开始可以到达的对象，而且这些对象引用的对象都已经被检查过了。
![image]()

在垃圾回收过程中，首先将所有对象标记为白色，然后从根节点开始，将可达的对象标记为灰色，然后逐步将灰色对象标记为黑色，并将它们引用的对象标记为灰色。这个过程一直持续到所有活动对象都被标记为黑色，所有不活动对象都被标记为白色。

![image]()

三色标记算法在并发环境下可能会出现问题，这个问题被称为“并发标记的漏标问题”。如下图所示的三色标记过程中，用户程序重新建立了从A对象到D对象的引用，但是因为程序中已经不存在灰色对象了，导致D对象本应被标记为灰色，而被错误地标记为白色，从而在垃圾回收时被错误地回收。

![image]()

为了解决这个问题，可以使用写屏障（Write Barrier）技术。写屏障像是一个钩子方法，当一个对象的引用被修改时，会触发执行一段指令代码，将这个对象重新标记为灰色，以确保不会错过任何需要被标记的对象。这样，就可以在并发环境下正确地进行垃圾回收。

![image]()

增量更新（Incremental Update）和快照在写时复制（Snapshot At The Beginning, SATB）都是垃圾回收中的写屏障技术，但是，它们在处理方式上有所不同。
1）增量更新：写屏障被触发时，如果一个黑色对象引用了一个白色对象，那么这个白色对象会被立即标记为灰色。
2）快照在写时复制：写屏障被触发时，会记录下被修改的引用，而不是立即修改对象的颜色。然后在并发标记结束时，根据这些记录，重新标记那些被错误地标记为非活动对象。

**未完待续**

**很高兴与你相遇！如果你喜欢本文内容，记得关注哦**
